<?xml version="1.0" encoding="utf-8"?>
<!--

  Technical Committee:
  OASIS Open Data Protocol (OData) TC
  https://www.oasis-open.org/committees/odata

  Chairs:
  - Ralf Handl (ralf.handl@sap.com), SAP SE
  - Michael Pizzo (mikep@microsoft.com), Microsoft

  Editors:
  - Ralf Handl (ralf.handl@sap.com), SAP SE
  - Michael Pizzo (mikep@microsoft.com), Microsoft

  Additional artifacts:
  This vocabulary is one component of a Work Product that also includes the following vocabulary components:
  - OData Core Vocabulary. Latest version: https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml.
  - OData Measures Vocabulary. Latest version: https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Measures.V1.xml.
  - OData Capabilities Vocabulary. Latest version: https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml.
  - OData Validation Vocabulary. Latest version: https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml.
  - OData Aggregation Vocabulary. Latest version: https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml.
  - OData Authorization Vocabulary. Latest version: https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml.
  - OData JSON Vocabulary. Latest version: https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.JSON .V1.xml.

  Related work:
  This vocabulary replaces or supersedes:
  - OData Version 4.0 Vocabulary components: OData JSON Vocabulary.
  This vocabulary is related to:
  - OData Version 4.01 Part 1: Protocol. Latest version: http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html.
  - OData Version 4.01 Part 2: URL Conventions. Latest version: http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html.
  - OData Common Schema Definition Language (CSDL) JSON Representation Version 4.01. Latest version: http://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html.
  - OData Common Schema Definition Language (CSDL) XML Representation Version 4.01. Latest version: http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html.
  - OData JSON Format Version 4.01. Latest version: http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html.
  - OData Extension for Data Aggregation Version 4.0. Latest version: http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/odata-data-aggregation-ext-v4.0.html.

  Abstract:
  This document defines terms, types, and functions for JSON streams.

-->
<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0">
  <edmx:Reference Uri="https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml">
    <edmx:Include Alias="Core" Namespace="Org.OData.Core.V1" />
  </edmx:Reference>
  <edmx:DataServices>
    <Schema xmlns="http://docs.oasis-open.org/odata/ns/edm" Namespace="Org.OData.JSON.V1" Alias="JSON">
      <Annotation Term="Core.Description">
        <String>Terms, types, and functions for JSON streams</String>
      </Annotation>
      <Annotation Term="Core.LongDescription">
        <String>OData [stream properties](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ManagingStreamProperties) allow embedding data of arbitrary media types,
and the OData JSON format allows [direct embedding of JSON data](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_StreamProperty) in request and response payloads.
          
This vocabulary defines a convenience [type for JSON streams](#JSON) streams as well as a term for referencing a [JSON Schema](#Schema) describing the structure of the JSON stream. 

In addition it defines two functions for [querying](#query) JSON streams and using a [primitive value](#value) extracted from a JSON stream in common expressions, for example in `$filter`, `$orderby`, or `$compute`.

**Example**

The `Employees` entity set has a JSON stream property `resume`:
```json
"container": {
  "$Kind": "EntityContainer",
  "Employees": { "$Collection": true, "$Type": "this.Employee" }
},
"Employee": {
  "$Kind": "EntityType",
  "$Key": ["empid"],
  "empid": { "$Type": "Edm.Int32" },
  "resume": { "$Type": "JSON.JSON", "$Nullable": true }
}
```

One of its entities has a `resume` value of
```json
{ 
  "ssn": "1234", 
  "lastname": "Doe", 
  "address": {
    "zipcode": "10022", 
    "street": "ABC st"
  },
  "experience": "excellent"
}
```

This allows to filter and sort by values in that resume, and extract parts of the resume as a dynamic JSON stream property
```http
GET http://www.example.com/mycompany/Employees
      ?$filter=resume/JSON.value('$.lastname') eq 'Doe'
      &amp;$orderby=resume/JSON.value('$.experience')
      &amp;$compute=resume/JSON.query('$.address') as address
      &amp;$expand=address
```
receiving
```json
{ 
  "@odata.context": "$metadata#Employees", 
  "value": [ 
    {
      "empid": 4711,
      "address": {
        "zipcode": "10022", 
        "street": "ABC st"
      }
    },
    ...
  ]
}
```
        </String>
      </Annotation>

      <Annotation Term="Core.Links">
        <Collection>
          <Record>
            <PropertyValue Property="rel" String="latest-version" />
            <PropertyValue Property="href" String="https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.JSON.V1.xml" />
          </Record>
          <Record>
            <PropertyValue Property="rel" String="alternate" />
            <PropertyValue Property="href" String="https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.JSON.V1.json" />
          </Record>
          <Record>
            <PropertyValue Property="rel" String="describedby" />
            <PropertyValue Property="href" String="https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.JSON.V1.md" />
          </Record>
        </Collection>
      </Annotation>

      <Term Name="Schema" Type="JSON.JSON" Nullable="false" AppliesTo="EntityType Parameter Property ReturnType Term TypeDefinition">
        <Annotation Term="Core.RequiresType" String="Edm.Stream" />
        <Annotation Term="Core.Description" String="The JSON Schema for JSON values of the annotated media entity type, property, parameter, return type, term, or type definition" />
        <Annotation Term="Core.LongDescription">
          <String>The schema can be a reference, i.e. `{"$ref":"url/of/schemafile#/path/to/schema/within/schemafile"}`</String>
        </Annotation>
      </Term>

      <Function Name="query" IsBound="true" IsComposable="true">
        <Annotation Term="Core.Description" String="Query a stream value of media type `application/json`, returning a stream value of media type `application/json`" />
        <Annotation Term="Core.LongDescription">
          <String>Extracts a JSON value, such as an array, object, or a JSON scalar value (string, number, boolean, or `null`) from the `input` JSON value:
- If `path` only consists of the root identifier followed by name and index selectors, it returns the identified single node within `input`, or `null` if no node is identified. 
- If `path` potentially identifies multiple nodes within `input` (by using descendant, wildcard, union, array subset, or filter selectors), it returns an array containing the identified nodes, or an empty array if no node is identified. 
- If `input` is not a valid JSON value, the function returns `null`.
- If `path` is `null`, not a valid [JSONPath expression](#Path), or does not match the structure of `input` (for example applying an index selector to a scalar value), the function returns `null`. 
          </String>
        </Annotation>
        <Parameter Name="input" Type="JSON.JSON">
          <Annotation Term="Core.Description" String="JSON input" />
        </Parameter>
        <Parameter Name="path" Type="JSON.Path">
          <Annotation Term="Core.Description" String="JSONPath expression to be applied to value of `expr`" />
        </Parameter>
        <ReturnType Type="JSON.JSON">
          <Annotation Term="Core.Description" String="JSON value resulting from applying `path` to `input`" />
        </ReturnType>
      </Function>

      <Function Name="value" IsBound="true">
        <Annotation Term="Core.Description" String="Query a stream value of media type `application/json`, returning an OData primitive value" />
        <Annotation Term="Core.LongDescription">
          <String>Extracts a single OData primitive value from the `input` JSON value:
- If `path` only consists of the root identifier followed by name and index selectors and identifies a single scalar JSON value (string, number, boolean, or `null`) within `input`, it returns the identified single value cast to an OData primitive value (see below).
- If `path` identifies multiple nodes within `input` (by using descendant, wildcard, union, array subset, or filter selectors), identifies an object or array, or does not identify any node, the function returns `null`.
- If `input` is not a valid JSON value, the function returns `null`.
- If `path` is `null`, not a valid [JSONPath expression](#Path), or does not match the structure of `input` (for example applying an index selector to a scalar value), the function returns `null`.

If a single non-null scalar JSON value is identified by `path` within `input`, the function returns that value as an OData primitive value of type
- `Edm.String` if the value is a JSON string
- `Edm.Boolean` if the value is `true` or `false`
- `Edm.Decimal` with unspecified precision and floating scale if the value is a JSON number
          </String>
        </Annotation>
        <Parameter Name="input" Type="JSON.JSON">
          <Annotation Term="Core.Description" String="JSON input" />
        </Parameter>
        <Parameter Name="path" Type="JSON.Path">
          <Annotation Term="Core.Description" String="JSONPath expression to be applied to value of `expr`" />
        </Parameter>
        <ReturnType Type="Edm.PrimitiveType">
          <Annotation Term="Core.Description" String="OData primitive value resulting from applying `path` to `input`" />
        </ReturnType>
      </Function>

      <TypeDefinition Name="JSON" UnderlyingType="Edm.Stream">
        <Annotation Term="Core.Description" String="Textual data of media type `application/json`" />
        <Annotation Term="Core.MediaType" String="application/json" />
        <Annotation Term="Core.AcceptableMediaTypes">
          <Collection>
            <String>application/json</String>
          </Collection>
        </Annotation>
      </TypeDefinition>


      <TypeDefinition Name="Path" UnderlyingType="Edm.String">
        <Annotation Term="Core.Description" String="[JSONPath](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html) expression" />
        <Annotation Term="Core.LongDescription">
          <String>Implementations SHOULD support at least the following subset of JSONPath:

Syntax Element | Description | Examples
---------------|-------------|--------
`$` | [root identifier](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html#root-identifier) | `$`
`[&lt;selector&gt;]` | [child segment](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html#child-segment) selects one child of a node; contains one [name selector](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html#name-selector) (single- or double-quoted string using JSON escaping rules) or [index selector](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html#index-selector) (non-negative decimal integer) | `$['foo']`, `$.foo["bar"]`, `$.bar[0]`, `$.bar[42]`
`.name` | shorthand for `['name']` | `$.foo`, `$.foo.bar`, `$.bar[42].baz`

Implementations MAY in addition support other JSONPath constructs, for example:

Syntax Element | Description | Examples
---------------|-------------|--------
`[&lt;selector&gt;]` | index selector with negative integer array index (counts from the end of the array) | `$.bar[-1]`
`[&lt;selectors&gt;]` | non-empty, comma-separated sequence of selectors | `$.foo['bar','baz']`, `$.bar[0,1,2,3,5,7,11]`
`..[&lt;selectors&gt;]` | [descendant segment](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html#descendant-segment): selects zero or more descendants of a node; contains one or more selectors, separated by commas | `$.foo..["bar"]`
`..name` | shorthand for `..['name']` | `$.foo..bar`
`*` | [wildcard selector](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html#name-selector): selects all children of a node | `$.foo[*]`, `$[*]`
`.*` | shorthand for `[*]` | `$.foo.*`, `$.*`
`..*` | shorthand for `..[*]` | `$.foo..*`, `$..*`
`[start:end]` | array subset by range of indices (including the item at _start_ and excluding the item at _end_ | `$.bar[2:5]`, same as `$.bar[2,3,4]`
`[start:]` | array subset from _start_ to end of array | `$.bar[2:]`
`[:n]` | the first _n_ array items | `$.bar[:4]`
`[-n:]` | the last _n_ array items | `$.bar[-3:]`
`[start:end:step]` | [array slice selector](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html#slice) |
`[?&lt;logical-expr&gt;]` | [filter selector](): selects particular children using a logical expression | 
`@` | [current node identifier](https://www.ietf.org/archive/id/draft-ietf-jsonpath-base-20.html#filter-selector) (valid only within filter selectors) | `$.bar[?@.baz==42]`

**References for JSONPath**
- Current IETF draft: https://datatracker.ietf.org/doc/draft-ietf-jsonpath-base/
- Historic site: https://goessner.net/articles/JsonPath/
- Node.js implementation: https://www.npmjs.com/package/jsonpath
- Java implementation: https://github.com/json-path/JsonPath
- Online evaluator: https://jsonpath.com/
          </String>
        </Annotation>
      </TypeDefinition>

    </Schema>
  </edmx:DataServices>
</edmx:Edmx>
